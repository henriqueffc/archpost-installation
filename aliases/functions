#### converter e comprimir imagens para os formatos jpg, png ou webp ####
compress_image() {
    if [ $# -lt 2 ]; then
        echo "Uso: compress_image <arquivo> <formato: jpg|png|webp>. Ex.: compress_image foto.png jpg"
        return 1
    fi

    local input="$1"
    local format="$2"

    if [ ! -f "$input" ]; then
        echo "Erro: arquivo '$input' não encontrado."
        return 1
    fi

    local base="${input%.*}"
    local output="${base}-compress.${format}"

    case "$format" in
        jpg|jpeg)
            magick "$input" -quality 95 "$output"
            ;;
        png)
            magick "$input" -strip \
                -define png:compression-filter=5 \
                -define png:compression-level=9 \
                -define png:compression-strategy=1 \
                -define png:exclude-chunk=all \
                "$output"
            ;;
        webp)
            magick "$input" -quality 90 "$output"
            ;;
        *)
            echo "Erro: formato inválido. Use 'jpg', 'png' ou 'webp'. Ex.: compress_image foto.png jpg"
            return 1
            ;;
    esac

    echo "Imagem comprimida gerada em: $output"
}

#### Executar app flatpaks sem a necessidade de usar o nome completo ####
flatrun() {
    flatpak run "$(flatpak list --columns=application | grep -F -i "$1")" "${@:2}"
}

#### Converter vídeo para compartilhar nas redes sociais ####
convert_video() {
ffmpeg -i $1 -c:v libx264 -crf 26 -profile:v main -preset slow -pix_fmt yuv420p -c:a aac -ar 44100 -ac 2 ${1%.*}-convert.mp4
}

#### Cortar uma parte do vídeo ####
corte_video() {
    if [ $# -lt 3 ]; then
        echo "Uso: corte_rapido <arquivo> <tempo_inicial> <duracao>"
        echo "Exemplo: corte_rapido video.mp4 00:00:30 10"
        return 1
    fi

    arquivo="$1"
    inicio="$2"
    duracao="$3"

    # Nome base do arquivo (sem extensão)
    nome_base="${arquivo%.*}"
    extensao="${arquivo##*.}"

    # Gera o nome de saída automaticamente
    saida="${nome_base}_corte_${inicio//:/-}_dur${duracao}.${extensao}"

    echo "Cortando \"$arquivo\"..."
    echo "Início: $inicio | Duração: $duracao | Saída: $saida"

    ffmpeg -ss "$inicio" -i "$arquivo" -t "$duracao" -c copy "$saida"

    echo "Corte finalizado!"
}

#### Compactar arquivos ####
function ua() {
  local usage=\
"Archive files and directories using a given compression algorithm.

Usage:   $0 <format> <files>
Example: $0 tbz PKGBUILD

Supported archive formats are:
7z, bz2, gz, lzma, lzo, rar, tar, tbz (tar.bz2), tgz (tar.gz),
tlz (tar.lzma), txz (tar.xz), tZ (tar.Z), xz, Z, zip, and zst."

  if [[ $# -lt 2 ]]; then
    print -u2 -- "$usage"
    return 1
  fi

  local ext="$1"
  local input="${2:a}"

  shift

  if [[ ! -e "$input" ]]; then
    print -u2 -- "$input not found"
    return 1
  fi

  # generate output file name
  local output
  if [[ $# -gt 1 ]]; then
    output="${input:h:t}"
  elif [[ -f "$input" ]]; then
    output="${input:r:t}"
  elif [[ -d "$input" ]]; then
    output="${input:t}"
  fi

  # if output file exists, generate a random name
  if [[ -f "${output}.${ext}" ]]; then
    output=$(mktemp "${output}_XXX") && rm "$output" || return 1
  fi

  # add extension
  output="${output}.${ext}"

  # safety check
  if [[ -f "$output" ]]; then
    print -u2 -- "output file '$output' already exists. Aborting"
    return 1
  fi

  case "$ext" in
    7z)           7z u                        "${output}"   "${@}" ;;
    bz2)          bzip2 -vcf                  "${@}" > "${output}" ;;
    gz)           gzip -vcf                   "${@}" > "${output}" ;;
    lzma)         lzma -vc -T0                "${@}" > "${output}" ;;
    lzo)          lzop -vc                    "${@}" > "${output}" ;;
    rar)          rar a                       "${output}"   "${@}" ;;
    tar)          tar -cvf                    "${output}"   "${@}" ;;
    tbz|tar.bz2)  tar -cvjf                   "${output}"   "${@}" ;;
    tgz|tar.gz)   tar -cvzf                   "${output}"   "${@}" ;;
    tlz|tar.lzma) XZ_OPT=-T0 tar --lzma -cvf  "${output}"   "${@}" ;;
    txz|tar.xz)   XZ_OPT=-T0 tar -cvJf        "${output}"   "${@}" ;;
    tZ|tar.Z)     tar -cvZf                   "${output}"   "${@}" ;;
    xz)           xz -vc -T0                  "${@}" > "${output}" ;;
    Z)            compress -vcf               "${@}" > "${output}" ;;
    zip)          zip -rull                   "${output}"   "${@}" ;;
    zst)          zstd -c -T0                 "${@}" > "${output}" ;;
    *) print -u2 -- "$usage"; return 1 ;;
  esac
}

#### rga-fzf ####
rga-fzf() {
	RG_PREFIX="rga --files-with-matches"
	local file
	file="$(
		FZF_DEFAULT_COMMAND="$RG_PREFIX '$1'" \
			fzf --sort --preview="[[ ! -z {} ]] && rga --pretty --context 5 {q} {}" \
				--phony -q "$1" \
				--bind "change:reload:$RG_PREFIX {q}" \
				--preview-window="70%:wrap"
	)" &&
	echo "opening $file" &&
	xdg-open "$file"
}

#### Function extract for common file formats ####
### Source - dotfile .zshrc by Derek Taylor on GitLab
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
function extract {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
 else
    for n in "$@"
    do
      if [ -f "$n" ] ; then
          case "${n%,}" in
            *.cbt|*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar)
                         tar xvf "$n"       ;;
            *.lzma)      unlzma ./"$n"      ;;
            *.bz2)       bunzip2 ./"$n"     ;;
            *.cbr|*.rar)       unrar x -ad ./"$n" ;;
            *.gz)        gunzip ./"$n"      ;;
            *.cbz|*.epub|*.zip)       unzip ./"$n"       ;;
            *.z)         uncompress ./"$n"  ;;
            *.7z|*.arj|*.cab|*.cb7|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.pkg|*.rpm|*.udf|*.wim|*.xar)
                         7z x ./"$n"        ;;
            *.xz)        unxz ./"$n"        ;;
            *.exe)       cabextract ./"$n"  ;;
            *.cpio)      cpio -id < ./"$n"  ;;
            *)
                         echo "extract: '$n' - unknown archive method"
                         return 1
                         ;;
          esac
      else
          echo "'$n' - file does not exist"
          return 1
      fi
    done
fi
}
IFS=$SAVEIFS

#### Função command-not-found ####
function command_not_found_handler {
    local purple='\e[1;35m' bright='\e[0;1m' green='\e[1;32m' reset='\e[0m'
    printf 'zsh: command not found: %s\n' "$1"
    local entries=(
        ${(f)"$(/usr/bin/pacman -F --machinereadable -- "/usr/bin/$1")"}
    )
    if (( ${#entries[@]} ))
    then
        printf "${bright}$1${reset} may be found in the following packages:\n"
        local pkg
        for entry in "${entries[@]}"
        do
            # (repo package version file)
            local fields=(
                ${(0)entry}
            )
            if [[ "$pkg" != "${fields[2]}" ]]
            then
                printf "${purple}%s/${bright}%s ${green}%s${reset}\n" "${fields[1]}" "${fields[2]}" "${fields[3]}"
            fi
            printf '    /%s\n' "${fields[4]}"
            pkg="${fields[2]}"
        done
    fi
    return 127
}

#### Função histórico de comandos com o fzf ####
hist() {
  local cmd=$(cat ~/.zsh_history | cut -d';' -f2- | fzf)
  if [[ -n $cmd ]]; then
    print -z "$cmd"
  fi
}
